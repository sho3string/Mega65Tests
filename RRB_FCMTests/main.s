.cpu _45gs02
#import "mega65defs.s"
#import "m65macros.s"

/*
	
	Demonstrates RRB via FCM mode using Masks. Borrows from Shallan's example delivered during a livestream
	https://github.com/smnjameson/M65_Examples/tree/main/2-NybbleMode
	https://www.youtube.com/watch?v=FgpIOo7b-NM

	This technique for implementing RRB via masking is described here, however the example uses NCM. The technique for doing RRB "sprites" in FCM is slightly different and described in 2)
	
	https://retrocogs.mega65.com/2025/08/14/vic-iv-graphics-using-rrb-for-pixies/

	1.
		What “slots” really are (why TAIL_SLOTS matters)
		Each slot = 4 bytes in the tail:
		screen tail slot: 2 bytes gotox + 2 bytes char
		color tail slot: 2 bytes control/mask + 2 bytes for char-cell color (you mostly leave these as COL_GOTOX,$00,$00,$00 via template, except you overwrite the first 2 bytes when using MARKER0)
		The VIC walks slots in order until it hits an EOL gotox (320). So:
		You must keep gotox monotonic non-decreasing inside a row.
		You must ensure an EOL exists after the last active slot, or you must hard-clear unused slots every frame.
		TAIL_SLOTS=5 exists mainly because the template provides 4 blank slots + an EOL slot.
	
	2.
		In FCM, the “mask byte” written via MARKER0/$98 is not a vertical (row) mask like in NCM.
		In FCM, it behaves like a column mask (8 bits = 8 pixel columns), so TopMask/BotMask tables (which are vertical concepts) will inevitably cut the ball in weird vertical ways once sub != 0. 
		
		That’s why when..
		Y=0,8,16... it may look fine (no fine scroll, so you’re not depending on the mask to “splice” scanlines)
		Y=4..7 turns into Pac-Man / wrong bite shapes (mask is biting columns, not scanlines)

		So: You cannot reproduce the NCM “splice top+bottom scanlines using TopMask/BotMask” method in FCM using this mask mechanism. It will always be wrong for fine Y.
		Therefore: rearrange tile data unless your tile data is pre-arranged ( difficult to edit directly )
		
		Given a Quad ( 2x2 pixie ) made up of 4 x 8x8px, swap the diaganols [2] and [3]. 
		This should ideally done after the tile data is generated by your character editor via a script rather than pre-arranging in an editor, which makes it difficult to make changes later.
		
		[1][2]	=>	[1][3]
		[3][4]		[2][4]
	
	
*/

.const COLOR_RAM		= $ff80000
.const NUM_ROWS			= 26
.const VISIBLE_COLS		= 40
.const TAIL_SLOTS		= 5
.const ROW_CELLS		= VISIBLE_COLS + (TAIL_SLOTS*2)	// 50 bytes
.const TAIL_OFF			= VISIBLE_COLS * 2					// 80 bytes after visible area
.const TAIL_LEN			= TAIL_SLOTS * 4        			// 20 bytes - 5 Slots
.const LOGICAL_ROW_SIZE	= (VISIBLE_COLS * 2) + TAIL_LEN		// 100 bytes
.const MARKER0			= $98								// colour tail byte0: enables GOTOX + rowmask + transparency as used by this method
.const COL_GOTOX		= $90								// transparency + gotox marker

.const SLOT0 = 0
.const SLOT1 = 4
.const SLOT2 = 8
.const SLOT3 = 12

.if (LOGICAL_ROW_SIZE != (VISIBLE_COLS*2 + TAIL_SLOTS*4)) {
  .error "LOGICAL_ROW_SIZE mismatch!"
}



/* 

tilesheet layout => sprite data layout

[1][2]	=>	[1][3]
[3][4]		[2][4]

*/

.const GLYPHS_PER_ROW 	= $10
.const CHR_TL 			= 0
.const CHR_TR 			= GLYPHS_PER_ROW
.const CHR_BL 			= $1
.const CHR_BR			= GLYPHS_PER_ROW + 1
.const CHR_B1			= $2
.const CHR_B2			= $12
.const BALL_CHAR_BASE 	= $0204

* = $02 "Basepage" virtual
  byte_02:			.byte 0
  byte_03:			.byte 0
  byte_04:			.byte 0
  byte_05:			.byte 0
  byte_06:			.byte 0
  byte_07:			.byte 0
  ypos:				.byte 0
  ypos2:			.byte 0
  x2_lo:			.byte 0
  x2_hi:			.byte 0
  ScreenVector:		.word 0
  ColorPtr:			.byte 0,0,0,0

BasicUpstart65(Entry)
* = $2016 "Basic Entry"

Entry: {
	sei
	lda #$35
	sta $01

	enable40Mhz()
	enableVIC4Registers()

	lda #$7f
	sta $dc0d
	sta $dd0d

	lda #$70
	sta $d640
	eom

	lda #%11111000
	trb $d030

	lda #$00
	sta $d01a

	lda #%00000111
	trb $d016

	cli

	// VIC4 setup
	lda #$20
	sta $d031

	// bit2=FCM for chars >$ff, bit0=16-bit char indices
	lda #%00000101
	sta $d054

	// logical row stride
	lda #<LOGICAL_ROW_SIZE
	sta $d058
	lda #>LOGICAL_ROW_SIZE
	sta $d059

	// 40 visible columns
	lda #ROW_CELLS
	sta $d05e

	// 26 rows
	lda #NUM_ROWS
	sta $d07b

	// screen base
	lda #<SCREEN_BASE
	sta $d060
	lda #>SCREEN_BASE
	sta $d061
	lda #$00
	sta $d062
	sta $d063

	lda #$00
	sta $d020
	lda #$05
	sta $d021

	// borders
	lda #$58
	sta $d048
	lda #$00
	sta $d049
	lda #$f8
	sta $d04a
	lda #$01
	sta $d04b
	lda #$58
	sta $d04e
	lda #$00
	sta $d04f

	jsr CopyPalette
	jsr CopyColors

	// ======= CRITICAL FIX: initialise ball state =======
	lda #$00
	sta BallX+0
	sta BallX+1
	lda #0
	sta BallY
	// ===================================================

loop:
	lda #$fe
	cmp $d012
	bne *-3
	lda #$ff
	cmp $d012
	bne *-3

	jsr RRBSprites
	jmp loop
}

// ---------------- demo ball ----------------
BallX: .word $0000
BallY: .byte $00

MoveBall: {
	inc BallY

	inc BallX + 0
	bne !+
	lda BallX + 1
	eor #$01 
	sta BallX + 1
	!:
	rts
}

// ---------------- RRB per-frame ----------------
RRBSprites: {
	jsr ClearRRBTails_ScreenDMA
	jsr ClearRRBTails_ColorDMA
	jsr MoveBall
	jsr DrawRRBSprites
	rts
}


SetScreenTail:
	lda BallX+0
    sta (ScreenVector),y
    iny
    lda BallX+1
	and #%00000011
    ora #%00010000           // fcm_yoffs_dir = 1  (the “subtract” direction)
    ora ypos                 // bits5..7 = fine Y (sub<<5)
    sta (ScreenVector),y
	rts
	
SetScreenTailBallX8:
	lda x2_lo
    sta (ScreenVector),y
    iny
    lda x2_hi
    and #%00000011
    ora #%00010000
    ora ypos
    sta (ScreenVector),y
	rts
	
SetScrClr:
	lda RRBRowTableLo,x
    sta ScreenVector+0
    lda RRBRowTableHi,x
    sta ScreenVector+1


	lda ColorRowOfsLo,x
	sta byte_02+0
	lda ColorRowOfsHi,x
	sta byte_02+1
	lda #((COLOR_RAM >> 16) & $ff)
	sta byte_02+2
	lda #((COLOR_RAM >> 24) & $ff)
	sta byte_02+3
	rts
	
SetColorTailSlot:
	lda #MARKER0
	sta ((byte_02)),z
	ldy byte_06
	rts
	
WriteScreenVector:
	sta (ScreenVector),y
    iny
    lda #$02
    sta (ScreenVector),y
	rts
	

DrawRRBSprites:

    // ================================================
    // sub = BallY & 7  (0..7)
    // ypos = (sub << 5) -> bits 5..7 for screen byte1
    // ================================================
    lda BallY
    and #$07
    sta byte_06

    lda byte_06
    asl
    asl
    asl
    asl
    asl
    sta ypos

    // coarse row = BallY >> 3
    lda BallY
    lsr
    lsr
    lsr
    tax

    // compute BallX+8 -> x2_lo/x2_hi
    lda BallX+0
    clc
    adc #8
    sta x2_lo
    lda BallX+1
    adc #0
    sta x2_hi

    // =========================
    // ROW X: TL + TR  (TopMask)
    // =========================
    cpx #NUM_ROWS
    lbcs done

    jsr SetScrClr

    // slot0 = TL @ BallX
    ldz #SLOT0+0
    jsr SetColorTailSlot
    lda TopMask,y
    ldz #SLOT0+1
    sta ((byte_02)),z
    ldy #SLOT0+0
    jsr SetScreenTail
    ldy #SLOT0+2
    lda #BALL_CHAR_BASE+CHR_TL
    jsr WriteScreenVector

    // slot1 = TR @ BallX+8
    ldz #SLOT1+0
    jsr SetColorTailSlot
    lda TopMask,y
    ldz #SLOT1+1
    sta ((byte_02)),z
    ldy #SLOT1+0
    jsr SetScreenTailBallX8
    ldy #SLOT1+2
    lda #BALL_CHAR_BASE+CHR_TR
    jsr WriteScreenVector
	

    // =========================
    // ROW X+1: BL + BR (BotMask)
    // =========================
    inx
    cpx #NUM_ROWS
    lbcs done

    jsr SetScrClr

    // slot0 = BL @ BallX
    ldz #SLOT0+0
    jsr SetColorTailSlot
    lda BotMask,y
    ldz #SLOT0+1
    sta ((byte_02)),z
    ldy #SLOT0+0
    jsr SetScreenTail
    ldy #SLOT0+2
    lda #BALL_CHAR_BASE+CHR_BL
    jsr WriteScreenVector
	

    // slot1 = BR @ BallX+8
    ldz #SLOT1+0
    jsr SetColorTailSlot
    lda BotMask,y
    ldz #SLOT1+1
    sta ((byte_02)),z
    ldy #SLOT1+0
    jsr SetScreenTailBallX8
    ldy #SLOT1+2
    lda #BALL_CHAR_BASE+CHR_BR
    jsr WriteScreenVector
	
	

    // slot2 = entering-left-half @ BallX
    ldz #SLOT2+0
    jsr SetColorTailSlot
    lda TopMask,y
    ldz #SLOT2+1
    sta ((byte_02)),z
    ldy #SLOT2+0
    jsr SetScreenTail
    ldy #SLOT2+2
    lda #BALL_CHAR_BASE+CHR_BL   // choose the entering tile you want here
    jsr WriteScreenVector
	

    // slot3 = entering-right-half @ BallX+8 (second layer)
    ldz #SLOT3+0
    jsr SetColorTailSlot
    lda TopMask,y
    ldz #SLOT3+1
    sta ((byte_02)),z
    ldy #SLOT3+0
    jsr SetScreenTailBallX8
    ldy #SLOT3+2
    lda #BALL_CHAR_BASE+CHR_BR   // choose the entering tile you want here
    jsr WriteScreenVector


    // ===========================
    // ROW X+2: blank spill (BotMask)
    // ===========================
    inx
    cpx #NUM_ROWS
    lbcs done

    jsr SetScrClr

    // slot2 blank @ BallX
    ldz #SLOT2+0
    jsr SetColorTailSlot
    lda BotMask,y
    ldz #SLOT2+1
    sta ((byte_02)),z
    ldy #SLOT2+0
    jsr SetScreenTail
    ldy #SLOT2+2
    lda #BALL_CHAR_BASE+CHR_B1
    jsr WriteScreenVector

    // slot3 blank @ BallX+8
    ldz #SLOT3+0
    jsr SetColorTailSlot
    lda BotMask,y
    ldz #SLOT3+1
    sta ((byte_02)),z
    ldy #SLOT3+0
    jsr SetScreenTailBallX8
    ldy #SLOT3+2
    lda #BALL_CHAR_BASE+CHR_B2
    jsr WriteScreenVector

done:
    rts




// ---------------- DMA clear tails ----------------
ClearRRBTails_ScreenDMA: {
  RunDMAJob(Job)
  rts
Job:
  DMAHeader($00, $00)
  .for (var r=0; r<NUM_ROWS; r++) {
    .var chain = (r != (NUM_ROWS-1))
    DMACopyJob(TailScreenTemplate,
      SCREEN_BASE + TAIL_OFF + r*LOGICAL_ROW_SIZE,
      TAIL_LEN,
      chain,
      false)
  }
}

ClearRRBTails_ColorDMA: {
  RunDMAJob(Job)
  rts
Job:
  DMAHeader($00, COLOR_RAM >> 20)
  .for (var r=0; r<NUM_ROWS; r++) {
    .var chain = (r != (NUM_ROWS-1))
    DMACopyJob(TailColorTemplate,
      COLOR_RAM + TAIL_OFF + r*LOGICAL_ROW_SIZE,
      TAIL_LEN,
      chain,
      false)
  }
}

// ---------------- palette/colors DMA ----------------
customPaletteTbl_1_Start:
Red:   .byte $ff,$13,$15,$e5,$76,$e7,$6e,$fe,$5f,$59,$bf,$ff,$ff,$3b,$ff,$00
customPaletteTbl_1_End:
Green: .byte $ff,$b1,$d2,$53,$a3,$75,$15,$c6,$c7,$57,$c8,$89,$7a,$d9,$cc,$00
Blue:  .byte $ff,$29,$8a,$1b,$7b,$2c,$00,$00,$00,$dc,$00,$00,$62,$bd,$08,$00

CopyPalette: {
  lda #%00000110
  sta $d070
  ldx #customPaletteTbl_1_End-customPaletteTbl_1_Start
!:
  lda Red,x
  sta $d100,x
  lda Green,x
  sta $d200,x
  lda Blue,x 
  sta $d300,x
  dex
  bpl !-
  rts
}

CopyColors: {
  RunDMAJob(Job)
  rts
Job:
  DMAHeader($00, COLOR_RAM>>20)
  DMACopyJob(COLORS, COLOR_RAM, LOGICAL_ROW_SIZE * NUM_ROWS, false, false)
}

// ---------------- background generator (quads) ----------------
.const MT_BASE_NORMAL = $0200
.const MT_BASE_ALT	= $0202
.const ALT_CHANCE		= 0.10

* = $4000
SCREEN_BASE: {
  .for (var mr=0; mr<(NUM_ROWS/2); mr++) {

    .var bases = List()

    .for (var mc=0; mc<(VISIBLE_COLS/2); mc++) {
      .var chooseAlt = random() < ALT_CHANCE
      .var base = chooseAlt ? MT_BASE_ALT : MT_BASE_NORMAL
      .eval bases.add(base)

      .byte <(base + 0), >(base + 0)
      .byte <(base + 1), >(base + 1)
    }

    // tail
    .byte $00,$00, $00,$00
    .byte $00,$00, $00,$00
	.byte $00,$00, $00,$00
    .byte $00,$00, $00,$00
    .byte <320, (>(320)) & 3, $00,$00

    .for (var mc=0; mc<(VISIBLE_COLS/2); mc++) {
      .var base2 = bases.get(mc)
      .byte <(base2 + GLYPHS_PER_ROW + 0), >(base2 + GLYPHS_PER_ROW + 0)
      .byte <(base2 + GLYPHS_PER_ROW + 1), >(base2 + GLYPHS_PER_ROW + 1)
    }

    // tail
    .byte $00,$00, $00,$00
    .byte $00,$00, $00,$00
	.byte $00,$00, $00,$00
    .byte $00,$00, $00,$00
    .byte <320, (>(320)) & 3, $00,$00
  }
}

COLORS: {
  .for (var r=0; r<NUM_ROWS; r++) {
    .for (var c=0; c<VISIBLE_COLS; c++) {
      .byte $00,$00
    }
    .byte COL_GOTOX,$00,  $00,$00
    .byte COL_GOTOX,$00,  $00,$00
    .byte COL_GOTOX,$00,  $00,$00
	.byte COL_GOTOX,$00,  $00,$00
    .byte COL_GOTOX,$00,  $00,$00
  }
}

* = $8000 "Sprites"
  .import binary "sprites_patched.bin"
  .fill 64,0

TopMask:
	.byte %11111111
	.byte %11111110
	.byte %11111100
	.byte %11111000
	.byte %11110000
	.byte %11100000
	.byte %11000000
	.byte %10000000

BotMask:
	.byte %00000000
	.byte %00000001
	.byte %00000011
	.byte %00000111
	.byte %00001111
	.byte %00011111
	.byte %00111111
	.byte %01111111

RRBRowTableLo:
  .fill NUM_ROWS, <[SCREEN_BASE + i*LOGICAL_ROW_SIZE + TAIL_OFF]
RRBRowTableHi:
  .fill NUM_ROWS, >[SCREEN_BASE + i*LOGICAL_ROW_SIZE + TAIL_OFF]

ColorRowOfsLo:
  .fill NUM_ROWS, <[i*LOGICAL_ROW_SIZE + TAIL_OFF]
ColorRowOfsHi:
  .fill NUM_ROWS, >[i*LOGICAL_ROW_SIZE + TAIL_OFF]

TailScreenTemplate:
	.byte $00,$00,$06,$02			// default is blank
	.byte $00,$00,$06,$02
	.byte $00,$00,$06,$02
	.byte $00,$00,$06,$02	
	.byte <320, (>(320)), $06,$02	

TailColorTemplate:
	.byte COL_GOTOX,$00,  $00,$00
	.byte COL_GOTOX,$00,  $00,$00
	.byte COL_GOTOX,$00,  $00,$00
	.byte COL_GOTOX,$00,  $00,$00
	.byte COL_GOTOX,$00,  $00,$00

